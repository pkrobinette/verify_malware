%% Create all vnnlib files corresponding to the specifications evaluated in this project
% L-inf pertubations -- 1 pixel, 2 pixel, 3 pixel

save_dir = "../../../vnnlib/malimg";
if ~exist(save_dir, 'dir')
   mkdir(save_dir);
end

% Load data
numClasses = 25;
n = 5; % number of images to evaluate per class
rng(2); % set random seed fix
[XData, YData, KeyData] = read_imgs_and_save(n);
% N = n * numClasses; % toal number of images to evaluate
% nR = 497;
% 
% % Adversarial attack
% % epsilon = [1, 2, 3]; % scale of attack
% epsilon = [1];
% 
% % Create the files for each I/O specs
% for e = 1:length(epsilon)
%     ep = epsilon(e)/255;
%     for i=1:N
%         % Create upper and lower bounds for input
%         [lb,ub] = L_inf_attack_new(XData(:,:,:,i), ep, 1, 0);
%         % create output spec
%         outputSpec = create_output_spec(numClasses, YData(i));
%         % Create vnnlib file
%         export2vnnlib(lb, ub, numClasses, outputSpec, save_dir+filesep+"malimg_"+string(epsilon(e))+"_"+string(i)+".vnnlib");
% 
%     end
% end


%% Helper Functions
% Define unsafe (not robust) property 
function Hs = create_output_spec(outSize, target)
    % @Hs: unsafe/not robust region defined as a HalfSpace
    %  - target: label idx of the given input set

    if target > outSize
        error("Target idx must be less than or equal to the output size of the NN.");
    end

    % Define HalfSpace Matrix and vector
    G = ones(outSize,1);
    G = diag(G);
    G(target, :) = [];
    G = -G;
    G(:, target) = 1;

    % Create HalfSapce to define robustness specification
    Hs = [];
    for i=1:height(G)
        Hs = [Hs; HalfSpace(G(i,:), 0)];
    end

end

function [lb,ub] = L_inf_attack_new(img, epsilon, max_value, min_value)
    imgSize = size(img);
    disturbance = epsilon * ones(imgSize, "like", img); % disturbance value
    lb = max(img - disturbance, min_value);
    ub = min(img + disturbance, max_value);
    lb = single(lb);
    lb = reshape(lb, [], 1);
    ub = single(ub);
    ub = reshape(ub, [], 1);
end


% function [lb,ub] = L_inf_attack(x,epsilon)
%     % Apply a L-infinity attack of value epsilon on each pixel on input image x 
%     % Return an ImageStar (IS)
%     n = size(x);
%     ub_max = ones(n);
%     lb_min = zeros(n);
%     lb = x - epsilon;
%     lb = max(lb, lb_min); % ensure no negative values
%     ub = x + epsilon;
%     ub = min(ub, ub_max); % ensure no values > 255 (max pixel value)
% end
% 
% function Hs = output_spec(target, outSize)
%     % @Hs: unsafe/not robust region defined as a HalfSpace
% 
%     if target > outSize
%         error("Target idx must be less than or equal to the output size of the NN.");
%     end
% 
%     % Define HalfSpace Matrix and vector
%     G = ones(outSize,1);
%     G = diag(G);
%     G(target, :) = [];
%     G = -G;
%     G(:, target) = 1;
%     g = zeros(height(G),1);
% 
%     % Create HalfSapce to define robustness specification
%     Hs = HalfSpace(G, g);
% end