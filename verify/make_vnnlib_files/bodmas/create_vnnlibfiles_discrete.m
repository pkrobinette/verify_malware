%% Create vnnlib files for the following datatypes
% type: discrete
% eps: [0.01; 0.05; 0.1]; % scale of attack

save_dir = "../../../vnnlib/bodmas/discrete";
N = 100; % number of samples to verify

if ~exist(save_dir, 'dir')
   mkdir(save_dir);
end

% Load feature analysis data
feature_info = readtable('../../../archive/bodmas-feature-analysis-NEW.csv');

% Load data
data = load('../../../archive/bodmas.mat');

% Let's start with a few images per class
X = data.X;
y = data.y;
y = y'; % transpose
% --> vnnlib is just y
y = y+1; % matlab predictions are 1 or 2 


% Scale the data-- > must be scaled!
X_scaled = zscore(X); % standard scaler equivalent

% Init variables
rng(0); % initialize random seed to select inputs to verfy
idxs = randperm(size(X_scaled,1),N);
XData = X_scaled(idxs,:);
YData = y(idxs);

% Adversarial attack
epsilon = [0.001; 0.005; 0.01]; % scale of attack

numClasses = 2;

% Create the files for each I/O specs
for e = 1:length(epsilon)
    ep = epsilon(e);
    for i=1:N
        % Create upper and lower bounds for input
        [lb,ub] = L_inf_attack_informed(XData(i,:), ep, feature_info);
        % Create output spec (halfspace)
        Hs = output_spec(YData(i), numClasses);
        % Create vnnlib file
        export2vnnlib(lb, ub, numClasses, Hs, save_dir+filesep+"bodmas_discrete_"+string(ep)+"_"+string(i)+".vnnlib");
    end
end

%% Helper Functions
function [lb, ub] = L_inf_attack_informed(x,epsilon,info)
    % This uses epsilon to scale the range between a features scaled
    % values.
    % Just looking at continuous features right now
    % Categories include: ['Continuous', 'Hash Categorical' ,
    %           'Hash Categorical Discrete', 'Discrete with large range' ,
    %           'Binary', 'Categorical' ,'Mem related']
    % Create masks for the categories of interest
    mask = strcmp(info.Category, "Discrete with large range");
    indices = find(mask);
    
    % get range for each feature
    range = info.scaled_max - info.scaled_min;
    diff = zeros(size(range));
    % only use the continuous variables
    diff(indices) = range(indices);
    % apply epsilong to every value
    diff = diff * epsilon;

    diff = diff';

    % --> lb = x - diff (diff is epsilon informed by info)
    lb = x - diff;
    % lb = max(lb, info.scaled_min.'); % ensure no values < min value

    % --> ub = x + diff (diff is epsilon informed by info)
    ub = x + diff;
    % ub = min(ub, info.scaled_max.'); % ensure no values > max value 
    % IS = ImageStar(lb,ub);
end

function Hs = output_spec(target, outSize)
    % @Hs: unsafe/not robust region defined as a HalfSpace

    if target > outSize
        error("Target idx must be less than or equal to the output size of the NN.");
    end

    % Define HalfSpace Matrix and vector
    G = ones(outSize,1);
    G = diag(G);
    G(target, :) = [];
    G = -G;
    G(:, target) = 1;
    g = zeros(height(G),1);

    % Create HalfSapce to define robustness specification
    Hs = HalfSpace(G, g);
end