%% Robustness verification of malware classification model

disp("Running MALIMG analysis...");

if ~exist("./results", 'dir')
   mkdir("results");
end

% List of trained models
models = ["malware_malimg_family_scaled_linear-25.onnx";
    "malware_malimg_family_scaled_4-25.onnx";
    "malware_malimg_family_scaled_16-25.onnx"];
numClasses = 25;

% Load data
n = 1; % number of images to evaluate per class
rng(2); % set random seed fix
[XData, YData, KeyData] = read_imgs(n);
N = n * numClasses; % toal number of images to evaluate
nR = 497;

% Verify every model
for ms = 1:length(models)

    % Load model
    modelName = models(ms);
    saveName = split(modelName,'.');
    saveName = saveName{1};
    netonnx = importONNXNetwork("../../../models/malimg/"+modelName, "InputDataFormats", "BCSS", "OutputDataFormats","BC");
    net = matlab2nnv(netonnx); % convert to NNV
    net.OutputSize = numClasses;
    disp("Running model:  "+saveName);
    
    % Define reachability options
    reachOptions.reachMethod = 'relax-star-area';
    reachOptions.relaxFactor = 0.5;
    
    % Size of attack 
    epsilon = [1/255; 2/255; 3/255];
    nE = length(epsilon); % number of different attacks to evaluate
    % Init vars
    res = zeros(N,nE); % robust result
    time = zeros(N,nE); % computation time
    met = repmat("relax", [N, nE]); % method used to compute result

    % Robustness analysis per epsilon for each model
    for e=1:nE
        eps = epsilon(e);
        for i=1:N
             % fewer prints for bigger runs
            if N > 10
                if mod(i, 10) == 0
                    disp("Verifying example:  "+string(i));
                    disp("Robust = "+string(sum(res(:,e)==1))+" out of " + string(i-1) + " images");
                end
            else
                disp("Verifying example:  "+string(i));
            end
            % get image star for image and epsilon value
            [IS, xRand] = L_inf_attack(XData(:,:,:,i), eps, nR);
            %
            % Try falsification, then relax star, if unknown, try approx-star
            %
            t = tic;
            % Falsification (500 samples between [img.lowerbound, img.upperbound])
            predictedLabels = predict(netonnx, xRand);
            [~, predictedLabels] = max(predictedLabels, [], 2);
            if any(predictedLabels ~= YData(i))
                res(i,e) = 0; % counterexample found
                time(i,e) = toc(t);
                met(i,e) = "counterexample";
                continue;
            end
            try
                % relax star
                temp = net.verify_robustness(IS,reachOptions,YData(i));
                % approx reachability if relax star unknown
                if temp ~= 1 && temp ~= 0
                    reachOptions = struct;
                    reachOptions.reachMethod = 'approx-star';
                    temp = net.verify_robustness(IS,reachOptions,YData(i));
                    met(i,e) = 'approx';
                end
            catch ME
                met(i,e) = ME.message;
                temp = -1;
            end
            res(i,e) = temp; % robust result
            time(i, e) = toc(t); % store computation time
            
            % reset reachOptions
            reachOptions.reachMethod = 'relax-star-area';
            reachOptions.relaxFactor = 0.5;
        end
        
        % Results
        disp("========  RESULTS  e: "+string(epsilon(e))+" ========");
        disp("");
        disp("Average computation time: "+string(sum(time(:,e))/N));
        disp("Robust = "+string(sum(res(:,e)==1))+" out of " + string(N) + " images");
        disp(" ");
        save("results/robustness_results_"+saveName,"res","time","epsilon","met");

    end

end

%% Helper Functions
function [IS, xRand] = L_inf_attack(x,epsilon,nR)
    % Apply a L-infinity attack of value epsilon on each pixel on input image x 
    % Return an ImageStar (IS), random images from initial set
    imgSize = size(x);
    disturbance = epsilon * ones(imgSize, "like", x); % disturbance value
    lb = max(x - disturbance, 0.0);
    ub = min(x + disturbance, 1.0);
    IS = ImageStar(single(lb), single(ub)); % default: single (assume onnx input models)

    % Create random images from initial set
    lb = reshape(lb, [4096,1]);
    ub = reshape(ub, [4096,1]);
    xB = Box(single(lb), single(ub));
    xRand = xB.sample(nR);
    xRand = reshape(xRand,[64,64,1,nR]);
    xRand(:,:,:,nR+1) = x; % add original image
    xRand(:,:,:,nR+2) = IS.im_lb; % add lower bound image
    xRand(:,:,:,nR+3) = IS.im_ub; % add upper bound image
end

