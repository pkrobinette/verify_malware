"""
Test malimg models trained via pytorch.
"""

from torch import nn
from torch import optim
from torchvision import datasets, transforms
from torch.utils.data import DataLoader, random_split
import numpy as np
import random
import torch
import os
import argparse
import tqdm
import torch.onnx
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from train_malimg_pytorch import CNN

DATAPATH = "../../archive/malimg_dataset/"
SAVEDIR = "../../models/malimg"
IMSIZE = 64
BATCH_SIZE = 32
SEED = 14

random.seed(SEED)
np.random.seed(SEED)
torch.manual_seed(SEED)

def get_args():
    """
    Get args
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("-d", "--datapath", type=str, default=DATAPATH)
    parser.add_argument("--savedir", type=str, default=SAVEDIR)
    parser.add_argument("-s", "--imsize", type=int, default=IMSIZE)
    parser.add_argument("-b", "--batch_size", type=int, default=BATCH_SIZE)
    args = parser.parse_args()
    return args


def load_data(datapath, imsize, batch_size):
    """
    Load malimg dataset. 
    """
    transform = transforms.Compose([
        transforms.Grayscale(),
        transforms.ToTensor(),
        transforms.Resize((imsize, imsize), antialias=True),
    ])
    
    train_dataset = datasets.ImageFolder(root=os.path.join(datapath, "train"), transform=transform)
    test_dataset = datasets.ImageFolder(root=os.path.join(datapath, "validation"), transform=transform)

    train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
    test_loader = DataLoader(test_dataset, batch_size=batch_size, shuffle=False)

    return train_loader, test_loader


def test_classifier(test_loader, args):
    """
    Test the classifier
    """
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model_paths = [f"{args.savedir}/malware_malimg_family_scaled_linear-25.pt", 
                   f"{args.savedir}/malware_malimg_family_scaled_4-25.pt", 
                   f"{args.savedir}/malware_malimg_family_scaled_16-25.pt"]

    conv_sizes = [0, 4, 16]
    model_stats = []
    #
    # Test
    #
    for path, conv1 in zip(model_paths, conv_sizes):
        model = CNN(1, conv1, 25).to(device)
        model.load_state_dict(torch.load(path))
        model.eval()

        all_preds = []
        all_labels = []

        with torch.no_grad():
            for data, labels in test_loader:
                data, labels = data.to(device), labels.to(device)
                outputs = model(data)
                _, predicted = torch.max(outputs, 1)
                all_preds.extend(predicted.cpu().numpy())
                all_labels.extend(labels.cpu().numpy())

        accuracy = accuracy_score(all_labels, all_preds)
        precision = precision_score(all_labels, all_preds, average='macro')
        recall = recall_score(all_labels, all_preds, average='macro')
        f1 = f1_score(all_labels, all_preds, average='macro')

        model_stats.append((accuracy, precision, recall, f1))
    #
    # Writing results to a file
    #
    if not os.path.exists("results"):
        os.mkdir("results")

    with open("results/Table_4_malimg.txt", "w") as f:
        f.write("Model | Accuracy | Precision | Recall | F1\n")
        f.write("--------------------------------------------\n")
        for m, stats in zip(["linear-2", "4-2", "16-2"], model_stats):
            f.write(f"{m} | {' | '.join(f'{x:.2f}' for x in stats)}\n")
    print("Test results saved to: results/Table_4_malimg.txt")

if __name__ == "__main__":
    #
    # Get args
    #
    args = get_args()
    #
    # Load data
    #
    _, test_loader = load_data(datapath=args.datapath, imsize=args.imsize, batch_size=args.batch_size)
    #
    # Test classifier
    #
    test_classifier(test_loader, args)