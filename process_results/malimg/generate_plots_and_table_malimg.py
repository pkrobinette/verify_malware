"""
Generate results plots and tables for MALIMG experiments.
"""

import os
import scipy.io
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import sys
import json
from collections import defaultdict
import glob

sns.set_theme()

# plot template
# plt.rcParams['text.usetex'] = True
fs = 20

font = {'family' : 'serif',
        'serif':['Computer Modern'],
        'size'   : fs-4}

CLASSES = ['Adialer.C', 'Agent.FYI', 'Allaple.A', 'Allaple.L', 'Alueron.gen!J', 'Autorun.K', 'C2LOP.P', 'C2LOP.gen!g', 'Dialplatform.B', 'Dontovo.A', 'Fakerean', 'Instantaccess', 'Lolyda.AA1', 'Lolyda.AA2', 'Lolyda.AA3', 'Lolyda.AT', 'Malex.gen!J', 'Obfuscator.AD', 'Rbot!gen', 'Skintrim.N', 'Swizzor.gen!E', 'Swizzor.gen!I', 'VB.AT', 'Wintrim.BX', 'Yuner.A']

# all of the epsilons are in % form
epsilons = [1, 2, 3]

def get_stats_from_json(model_name, path):
    """
    Pull stats from experiments
    """
    assert model_name in ["none-25", "4-25", "16-25", "linear-25"], "incorrect model name. "
    #
    # get result file names for model
    #
    file_paths = [f for f in os.listdir(path) if model_name in f]
     
    res = {}
    time = {}
    #
    # PUll results
    #
    for file_path in file_paths:
        with open(os.path.join(path, file_path), 'r') as file:
            data = json.load(file)
        
        if "res" in file_path:
            for k in data.keys():
                res[k] = data[k]["holds"]
        else:
            for k in data.keys():
                time[k] = data[k]
    #
    # Return the results
    #
    return res, time


def make_plots():
    """
    Make plots of the experimental data.
    """
    if os.path.exists("figures") == 0:
        os.mkdir("figures")
        
    models = ["linear-25", "4-25", "16-25"]
    get_name = lambda mod: f"../../results/raw/nnv_results/malimg/robustness_results_malware_malimg_family_scaled_{mod}.mat"
    nnenum_path = "../../results/raw/nnenum_results/malimg"
    #
    # Get nnenum stats
    #
    nnenum_res = {}
    nnenum_time = {}
    for m in models:
        nnenum_res[m], nnenum_time[m] = get_stats_from_json(m, nnenum_path)

    res = {}
    time = {}
    eps = epsilons
    #
    # Gather data from NNV
    #
    for m in models:
        # load data
        mat = scipy.io.loadmat(get_name(m))
        # load res, time keys
        r = mat["res"]
        t = mat["time"]
        if m not in res:
            res[m] = {}
        if m not in time:
            time[m] = {}
        for i in range(len(eps)):
            sat = [1 if val[i] == 1 else 0 for val in r]
            res[m][eps[i]] = sum(sat)
        
            # time is the mean
            time[m][eps[i]] = round(np.mean([val[i] for val in t]), 2)
        
    # Create Plots
    #
    # Create the figure and axis objects for both plots
    color = ["blue", "orange", "green"]
    # NUM = len(r)
    NUM = 125
    fig1, ax1 = plt.subplots()
    fig2, ax2 = plt.subplots()
    
    # Plot the time data
    for i, key in enumerate(models):
        ax1.plot(eps, time[key].values(), ".-", label=key + " *", color=color[i] )
        ax1.plot(eps, nnenum_time[key].values(), linestyle='--', marker='.', label=key+" ^", color=color[i])
    
    # Set title and labels for the time plot
    # ax1.set_title("Time Plot", fontsize=fs)
    ax1.set_xlabel("Epsilon Perturbation (Pixel)", fontsize=fs)
    ax1.set_ylabel("Time $(s)$", fontsize=fs)
    ax1.tick_params(axis='x', labelsize=fs)
    ax1.tick_params(axis='y', labelsize=fs)
    # ax1.set_ylim(0, 1.3)
    # if c == "all":
    #     ax1.set_yticks([0.0, 0.5, 1.0, 1.5])
    #     ax1.legend(loc="upper left", ncols=3, fontsize=fs-4)  # show legend
    # else:
    #     ax1.set_yticks([0.0, 0.1, 0.2, 0.3])
    #     ax1.legend(loc="lower left", ncols=3, fontsize=fs-4)  # show legend
    # tix = [r''+str(ep)+'\%' for ep in eps]
    # ax1.set_xticks(eps, tix)
    ax1.set_xticks(eps)
    
    # Plot the res data
    for i, key in enumerate(models):
        ax2.plot(eps, res[key].values(), ".-", label=key + " *", color=color[i])
        ax2.plot(eps, nnenum_res[key].values(), linestyle='--', marker='.', label=key+" ^", color=color[i])
    ax2.plot(eps, [NUM]*len(eps), "--", color="black", label="Total")
    
    # Set title and labels for the res plot
    # ax2.set_title("Res Plot", fontsize=fs)
    ax2.set_xlabel("Epsilon Perturbation", fontsize=fs)
    ax2.set_ylabel("No. Certified Robust", fontsize=fs)
    ax2.legend(loc='upper center', bbox_to_anchor=(0.5, 1.35), ncol=3, fontsize=fs-4)
    # ax2.legend(loc='lower left', ncols=2, fontsize=fs-4)  # show legend
    ax2.tick_params(axis='x', labelsize=fs)
    ax2.tick_params(axis='y', labelsize=fs)
    ax2.set_ylim(0, NUM+5)
    ax2.set_xticks(eps)
    ax2.set_yticks([0, 25, 50, 75, 100, 125])
    
    # fig1.savefig(f"figures/Fig_{I+4}b_{c}.pdf", bbox_inches='tight', dpi=300)
    # fig2.savefig(f"figures/Fig_{I+4}a_{c}.pdf", bbox_inches='tight', dpi=300)
    fig1.savefig(f"figures/malimg_time.pdf", bbox_inches='tight', dpi=300)
    fig2.savefig(f"figures/malimg_res.pdf", bbox_inches='tight', dpi=300)
        
    return nnenum_res, nnenum_time, res, time

def make_tables(nnenum_res, nnenum_time, nnv_res, nnv_time, filename="latex_table.txt"):
    """
    Make a table of bodmas results.
    """
    # Define the header of the LaTeX table
    table_headers = "\\begin{tabularx}{\\textwidth}{YXXYYY} \n"
    header = "\\multirow{2}{*}{Metric} & \\multirow{2}{*}{Model} & \\multirow{2}{*}{Tool} &\\multicolumn{3}{c}{Epsilon} \\\\\n"

    # Start creating the table
    table_content = table_headers + "\\toprule \n" + header
    #
    # Add epsilon values
    #
    table_content += f" & & "
    for epsilon in nnv_res["linear-25"]:
        table_content += f"& {epsilon} pixel "
    table_content += "\\\\\n \\midrule \n"
    table_content += f"\\multirow{{6}}{{=}}{{\\rotatebox{{90}}{{CRA}}}}"
    #
    # Add values
    #
    for model, _ in nnenum_res.items():            
        table_content += f" & \\multirow{{2}}{{*}}{{{model}}} & nnv "

        for epsilon in nnv_res[model]:
            nnv_result = nnv_res[model].get(epsilon, '-')
            table_content += f"& {nnv_result} "
            
        table_content += "\\\\\n"
        table_content += f" &  & nnenum "
        for epsilon in nnenum_res[model]:
            nnenum_result = nnenum_res[model].get(epsilon, '-')
            table_content += f"& {nnenum_result} "
        table_content += "\\\\\n"
        if model == "16-25":
            table_content += "\\midrule"
        else:
            table_content += "\\cline{3-6} \n \\rule{0pt}{3ex} \n"
    #
    #
    #
    table_content += f"\\multirow{{6}}{{=}}{{\\rotatebox{{90}}{{Time (s)}}}}"
    for model, _ in nnenum_time.items():            
        table_content += f" & \\multirow{{2}}{{*}}{{{model}}} & nnv "

        for epsilon in nnv_time[model]:
            nnv_result = nnv_time[model].get(epsilon, '-')
            table_content += f"& {nnv_result:.4f} "
            
        table_content += "\\\\\n"
        table_content += f" &  & nnenum "
        for epsilon in nnenum_time[model]:
            nnenum_result = nnenum_time[model].get(epsilon, '-')
            table_content += f"& {nnenum_result:.4f} "
        table_content += "\\\\\n"
        if model == "16-2":
            table_content += "\\bottomrule"
        else:
            table_content += "\\cline{3-6} \n \\rule{0pt}{3ex} \n"

    # Save to a text file
    with open(filename, "w") as file:
        file.write(table_content)

    print(f"Table saved to {filename}")

def make_readable_tables(nnenum_res, nnenum_time, nnv_res, nnv_time, filename="readable_table.txt"):
    """
    Make a human-readable table of bodmas results.
    """
    print(nnv_res)

    # Header for the table
    header = f"{'Metric':<15}{'Model':<15}{'Tool':<10}{'1/255':<10}{'2/255':<10}{'3/255':<10}\n"
    separator = "-" * len(header) + "\n"

    with open(filename, "w") as file:
        file.write(header)
        file.write(separator)

        # Writing data for CRA and Time
        for metric, data in [('CRA', nnenum_res), ('Time (s)', nnenum_time)]:
            for model in data.keys():
                for tool in ['nnv', 'nnenum']:
                    line = f"{metric:<15}{model:<15}{tool:<10}"
                    for epsilon in epsilons:
                        if tool == "nnenum":
                            if metric == "CRA":
                                result = nnenum_res[model].get(str(epsilon), "-")
                            else:
                                result = nnenum_time[model].get(str(epsilon), "-")
                        else:
                            if metric == "CRA":
                                result = nnv_res[model].get(epsilon, "-")
                            else:
                                result = nnv_time[model].get(epsilon, "-")
                        if metric == 'Time (s)' and isinstance(result, (float, int)):
                            result = f"{result:.4f}"  # Formatting time to 4 decimal places
                        line += f"{result:<10}"
                    line += "\n"
                    file.write(line)
                file.write(separator)

    print(f"Table saved to {filename}")

def make_per_class_table(epsilon, filename="per_class_latex_table.txt"):
    """
    Make plots of the experimental data.
    """  
    assert epsilon in epsilons, "Invalid epsilon perturbation."
    models = ["linear-25", "4-25", "16-25"]
    get_name = lambda mod: f"../../verify/nnv_verify/malimg/results/robustness_results_malware_malimg_family_scaled_{mod}.mat"
    data_path = "../../archive/malimg_dataset/train"
    res = {}
    #
    # Gather data from NNV
    #
    for m in models:
        mat = scipy.io.loadmat(get_name(m))
        # load res, time keys
        r = mat["res"]
        res[m] = {eps: [0]*25 for eps in epsilons}
        clas = 0
        for i in range(len(r)):
            # Index the class (malware family)
            if i%5 == 0 and i != 0:
                clas += 1
            for eps in epsilons:
                res[m][eps][clas] += 1 if r[i][eps-1] == 1 else 0

    # Define the header of the LaTeX table
    table_headers = "\\begin{tabular}{ccccc} \n"
    header1 = "\\multirow{2}{*}{Malimg Class (Family)} & \\multicolumn{3}{c}{Robustness Accuracy} & \multirow{2}{*}{Training Samples}\\\\\n"
    header2 = "& linear-25 & 4-25 & 16-25 & \\\\\n"
    table_content = table_headers + "\\toprule \n" + header1 + header2 + "\\midrule \n"
    #
    # Add epsilon values
    #
    for i in range(len(CLASSES)):
        table_content += f"{CLASSES[i]} "
        for m in models:
            table_content += f"& {res[m][epsilon][i]} "
            
        table_content += f"& {len(glob.glob(os.path.join(data_path, CLASSES[i], '*.png')))}\\\\\n"
    table_content += "\\bottomrule \n \\end{tabular}"
    # Save to a text file
    with open(filename, "w") as file:
        file.write(table_content)
    print(f"saved to {filename}")

import os
import glob

def make_per_class_readable_table(epsilon, filename="per_class_readable_table.txt"):
    """
    Make a human-readable table of per-class results.
    """
    assert epsilon in epsilons, "Invalid epsilon perturbation."
    models = ["linear-25", "4-25", "16-25"]
    get_name = lambda mod: f"../../results/raw/nnv_results/malimg/robustness_results_malware_malimg_family_scaled_{mod}.mat"
    # nnenum_path = "../../results/raw/nnenum_results/malimg"
    # get_name = lambda mod: f"../../verify/nnv_verify/malimg/results/robustness_results_malware_malimg_family_scaled_{mod}.mat"
    data_path = "../../archive/malimg_dataset/train"
    res = {}
    #
    # Gather data from NNV
    #
    for m in models:
        mat = scipy.io.loadmat(get_name(m))
        # load res, time keys
        r = mat["res"]
        res[m] = {eps: [0]*len(CLASSES) for eps in epsilons}
        clas = 0
        for i in range(len(r)):
            # Index the class (malware family)
            if i%5 == 0 and i != 0:
                clas += 1
            for eps in epsilons:
                res[m][eps][clas] += 1 if r[i][eps-1] == 1 else 0

    # Header for the table
    header = f"{'Malimg Class (Family)':<30}{'linear-25':<10}{'4-25':<10}{'16-25':<10}{'Training Samples':<20}\n"
    separator = "-" * len(header) + "\n"

    # Writing the table
    with open(filename, "w") as file:
        file.write(header)
        file.write(separator)
        for i, class_name in enumerate(CLASSES):
            line = f"{class_name:<30}"
            for m in models:
                line += f"{res[m][epsilon][i]:<10}"
            training_samples = len(glob.glob(os.path.join(data_path, class_name, '*.png')))
            line += f"{training_samples:<20}\n"
            file.write(line)
        file.write(separator)

    print(f"Table saved to {filename}")

    
            
if __name__ == "__main__":
    nnenum_res, nnenum_time, nnv_res, nnv_time = make_plots()
    # make_tables(nnenum_res, nnenum_time, nnv_res, nnv_time, filename="table_6.txt")
    make_readable_tables(nnenum_res, nnenum_time, nnv_res, nnv_time, filename="table_6.txt")
    # make_per_class_table(epsilon=2, filename="table_7.txt")
    make_per_class_readable_table(epsilon=2, filename="table_7.txt")
        
    
