"""
Generate results plots and tables for MALIMG experiments.
"""


import os
import scipy.io
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import sys
import json
from collections import defaultdict

sns.set_theme()

# plot template
# plt.rcParams['text.usetex'] = True
fs = 20

font = {'family' : 'serif',
        'serif':['Computer Modern'],
        'size'   : fs-4}

# all of the epsilons are in % form
epsilons = [1, 2, 3]

def get_stats_from_json(model_name, path):
    """
    Pull stats from experiments
    """
    assert model_name in ["none-25", "4-25", "16-25", "linear-25"], "incorrect model name. "
    #
    # get result file names for model
    #
    file_paths = [f for f in os.listdir(path) if model_name in f]
     
    res = {}
    time = {}
    #
    # PUll results
    #
    for file_path in file_paths:
        with open(os.path.join(path, file_path), 'r') as file:
            data = json.load(file)
        
        if "res" in file_path:
            for k in data.keys():
                res[k] = data[k]["holds"]
        else:
            for k in data.keys():
                time[k] = data[k]
    #
    # Return the results
    #
    return res, time


def make_plots():
    """
    Make plots of the experimental data.
    """
    if os.path.exists("figures") == 0:
        os.mkdir("figures")
        
    models = ["linear-25", "4-25", "16-25"]
    get_name = lambda mod: f"../../verify/nnv_verify/malimg/results/robustness_results_malware_malimg_family_scaled_{mod}.mat"
    nnenum_path = "/Users/probinette/Google Drive/My Drive/MALWARE/results/malimg"
    #
    # Get nnenum stats
    #
    nnenum_res = {}
    nnenum_time = {}
    for m in models:
        nnenum_res[m], nnenum_time[m] = get_stats_from_json(m, nnenum_path)

    res = {}
    time = {}
    eps = epsilons
    #
    # Gather data from NNV
    #
    for m in models:
        # load data
        mat = scipy.io.loadmat(get_name(m))
        # load res, time keys
        r = mat["res"]
        t = mat["time"]
        if m not in res:
            res[m] = {}
        if m not in time:
            time[m] = {}

        for i in range(len(eps)):
            # result is the number == 1
            sat = [1 if val[i] == 1 else 0 for val in r]
            res[m][eps[i]] = sum(sat)
            
            # time is the mean
            time[m][eps[i]] = round(np.mean([val[i] for val in t]), 2)
        
    # Create Plots
    #
    # Create the figure and axis objects for both plots
    color = ["blue", "orange", "green"]
    # NUM = len(r)
    NUM = 125
    fig1, ax1 = plt.subplots()
    fig2, ax2 = plt.subplots()
    
    # Plot the time data
    for i, key in enumerate(models):
        ax1.plot(eps, time[key].values(), ".-", label=key + " *", color=color[i] )
        ax1.plot(eps, nnenum_time[key].values(), linestyle='--', marker='.', label=key+" ^", color=color[i])
    
    # Set title and labels for the time plot
    # ax1.set_title("Time Plot", fontsize=fs)
    ax1.set_xlabel("Epsilon Perturbation (%)", fontsize=fs)
    ax1.set_ylabel("Time $(s)$", fontsize=fs)
    ax1.tick_params(axis='x', labelsize=fs)
    ax1.tick_params(axis='y', labelsize=fs)
    # ax1.set_ylim(0, 1.3)
    # if c == "all":
    #     ax1.set_yticks([0.0, 0.5, 1.0, 1.5])
    #     ax1.legend(loc="upper left", ncols=3, fontsize=fs-4)  # show legend
    # else:
    #     ax1.set_yticks([0.0, 0.1, 0.2, 0.3])
    #     ax1.legend(loc="lower left", ncols=3, fontsize=fs-4)  # show legend
    # tix = [r''+str(ep)+'\%' for ep in eps]
    # ax1.set_xticks(eps, tix)
    ax1.set_xticks(eps)
    
    # Plot the res data
    for i, key in enumerate(models):
        ax2.plot(eps, res[key].values(), ".-", label=key + " *", color=color[i])
        ax2.plot(eps, nnenum_res[key].values(), linestyle='--', marker='.', label=key+" ^", color=color[i])
    ax2.plot(eps, [NUM]*len(eps), "--", color="black", label="Total")
    
    # Set title and labels for the res plot
    # ax2.set_title("Res Plot", fontsize=fs)
    ax2.set_xlabel("Epsilon Perturbation (%)", fontsize=fs)
    ax2.set_ylabel("SAT", fontsize=fs)
    ax2.legend(loc='upper center', bbox_to_anchor=(0.5, 1.35), ncol=3, fontsize=fs-4)
    # ax2.legend(loc='lower left', ncols=2, fontsize=fs-4)  # show legend
    ax2.tick_params(axis='x', labelsize=fs)
    ax2.tick_params(axis='y', labelsize=fs)
    ax2.set_ylim(0, NUM+5)
    ax2.set_xticks(eps)
    ax2.set_yticks([0, 25, 50, 75, 100, 125])
    
    # fig1.savefig(f"figures/Fig_{I+4}b_{c}.pdf", bbox_inches='tight', dpi=300)
    # fig2.savefig(f"figures/Fig_{I+4}a_{c}.pdf", bbox_inches='tight', dpi=300)
    fig1.savefig(f"figures/malimg_time.pdf", bbox_inches='tight', dpi=300)
    fig2.savefig(f"figures/malimg_res.pdf", bbox_inches='tight', dpi=300)
        
    return nnenum_res, nnenum_time, res, time

def make_tables(nnenum_res, nnenum_time, nnv_res, nnv_time, filename="latex_table.txt"):
    """
    Make a table of bodmas results.
    """
    # Define the header of the LaTeX table
    table_headers = "\\begin{tabularx}{\\textwidth}{YXXYYY} \n"
    header = "\\multirow{2}{*}{Metric} & \\multirow{2}{*}{Model} & \\multirow{2}{*}{Tool} &\\multicolumn{3}{c}{Epsilon} \\\\\n"

    # Start creating the table
    table_content = table_headers + "\\toprule \n" + header
    #
    # Add epsilon values
    #
    table_content += f" & & "
    for epsilon in nnv_res["linear-25"]:
        table_content += f"& {epsilon} pixel "
    table_content += "\\\\\n \\midrule \n"
    table_content += f"\\multirow{{6}}{{=}}{{\\rotatebox{{90}}{{Robust Accuracy}}}}"
    #
    # Add values
    #
    for model, _ in nnenum_res.items():            
        table_content += f" & \\multirow{{2}}{{*}}{{{model}}} & nnv "

        for epsilon in nnv_res[model]:
            nnv_result = nnv_res[model].get(epsilon, '-')
            table_content += f"& {nnv_result} "
            
        table_content += "\\\\\n"
        table_content += f" &  & nnenum "
        for epsilon in nnenum_res[model]:
            nnenum_result = nnenum_res[model].get(epsilon, '-')
            table_content += f"& {nnenum_result} "
        table_content += "\\\\\n"
        if model == "16-25":
            table_content += "\\midrule"
        else:
            table_content += "\\cline{3-6} \n \\rule{0pt}{3ex} \n"
    #
    #
    #
    table_content += f"\\multirow{{6}}{{=}}{{\\rotatebox{{90}}{{Time (s)}}}}"
    for model, _ in nnenum_time.items():            
        table_content += f" & \\multirow{{2}}{{*}}{{{model}}} & nnv "

        for epsilon in nnv_time[model]:
            nnv_result = nnv_time[model].get(epsilon, '-')
            table_content += f"& {nnv_result:.4f} "
            
        table_content += "\\\\\n"
        table_content += f" &  & nnenum "
        for epsilon in nnenum_time[model]:
            nnenum_result = nnenum_time[model].get(epsilon, '-')
            table_content += f"& {nnenum_result:.4f} "
        table_content += "\\\\\n"
        if model == "16-2":
            table_content += "\\bottomrule"
        else:
            table_content += "\\cline{3-6} \n \\rule{0pt}{3ex} \n"

    # Save to a text file
    with open(filename, "w") as file:
        file.write(table_content)

    print(f"Table saved to {filename}")
    
            
if __name__ == "__main__":
    nnenum_res, nnenum_time, nnv_res, nnv_time = make_plots()
    make_tables(nnenum_res, nnenum_time, nnv_res, nnv_time)
        
    
