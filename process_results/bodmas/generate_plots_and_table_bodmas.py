"""
Generate results plots and tables for BODMAS experiments.
"""


import os
import scipy.io
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import sys
import json
from collections import defaultdict

sns.set_theme()

# plot template
# plt.rcParams['text.usetex'] = True
fs = 20

font = {'family' : 'serif',
        'serif':['Computer Modern'],
        'size'   : fs-4}

# all of the epsilons are in % form
epsilons = {"all":[0.01, 0.05, 0.1], # ==> in percentage form
            "continuous_discrete":[0.1, 0.5, 1],
            "continuous": [1, 5, 10],
            "discrete": [0.1, 0.5, 1]}

def get_stats_from_json(model_name, path):
    """
    Pull stats from experiments
    """
    assert model_name in ["none-2", "4-2", "16-2", "linear-2"], "incorrect model name. "
    #
    # get result file names for model
    #
    result_files = []
    for f in os.listdir(path):
        if model_name in f:
            result_files.append(f)
     
    res = {}
    time = {}
    #
    # For each coverage type, pull results
    #
    for c in ["all", "continuous_discrete", "discrete", "continuous"]:
        coverage_files = [f for f in result_files if c in f]
        # remove these files from the list to prevent double files
        result_files = [f for f in result_files if f not in coverage_files]
        for file_path in coverage_files:
            with open(os.path.join(path, file_path), 'r') as file:
                data = json.load(file)
    
            if "res" in file_path:
                res[c] = {}
                for k in data.keys():
                    new_key = float(k)*100      # update the keys to match the actual percentage
                    res[c][new_key] = data[k]["holds"]
            else:
                time[c] = {}
                for k in data.keys():
                    new_key = float(k)*100      # update the keys to match actual percentage
                    time[c][new_key] = data[k]
    #
    # Return the results
    #
    return res, time


def make_plots():
    """
    Make plots of the experimental data.
    """
    if os.path.exists("figures") == 0:
        os.mkdir("figures")
        
    coverage = ["all", "continuous_discrete", "discrete", "continuous"]
    models = ["none-2", "4-2", "16-2"]
    get_name = lambda mod, cov: f"../../verify/nnv_verify/bodmas/results/robustness_malware_bodmas_binary_scaled_{mod}_{cov}.mat"
    nnenum_path = "/Users/probinette/Google Drive/My Drive/MALWARE/results/bodmas"
    #
    # Get nnenum stats
    #
    nnenum_res = {}
    nnenum_time = {}
    for m in models:
        nnenum_res[m], nnenum_time[m] = get_stats_from_json(m, nnenum_path)

    res = {}
    time = {}
    for I, c in enumerate(coverage):
        print("Creating plots for: ", c)
        # res = {}
        # time = {}
        eps = epsilons[c]
        #
        # Gather data from NNV
        #
        for m in models:
            # load data
            mat = scipy.io.loadmat(get_name(m, c))
            # load res, time keys
            r = mat["res"]
            t = mat["time"]

            if m not in res:
                res[m] = {}
            if c not in res[m]:
                res[m][c] = {}
            if m not in time:
                time[m] = {}
            if c not in time[m]:
                time[m][c] = {}
            
            for i in range(len(eps)):
                # result is the number == 1
                sat = [1 if val[i] == 1 else 0 for val in r]
                res[m][c][eps[i]] = sum(sat)
                
                # time is the mean
                time[m][c][eps[i]] = round(np.mean([val[i] for val in t]), 2)
        
        # Create Plots
        #
        # Create the figure and axis objects for both plots
        color = ["blue", "orange", "green"]
        # NUM = len(r)
        NUM = 100
        fig1, ax1 = plt.subplots()
        fig2, ax2 = plt.subplots()
        
        # Plot the time data
        for i, key in enumerate(models):
            ax1.plot(eps, time[key][c].values(), ".-", label=key + " *", color=color[i] )
            ax1.plot(eps, nnenum_time[key][c].values(), linestyle='--', marker='.', label=key+" ^", color=color[i])
        
        # Set title and labels for the time plot
        # ax1.set_title("Time Plot", fontsize=fs)
        ax1.set_xlabel("Epsilon Perturbation (%)", fontsize=fs)
        ax1.set_ylabel("Time $(s)$", fontsize=fs)
        ax1.tick_params(axis='x', labelsize=fs)
        ax1.tick_params(axis='y', labelsize=fs)
        # ax1.set_ylim(0, 1.3)
        # if c == "all":
        #     ax1.set_yticks([0.0, 0.5, 1.0, 1.5])
        #     ax1.legend(loc="upper left", ncols=3, fontsize=fs-4)  # show legend
        # else:
        #     ax1.set_yticks([0.0, 0.1, 0.2, 0.3])
        #     ax1.legend(loc="lower left", ncols=3, fontsize=fs-4)  # show legend
        # tix = [r''+str(ep)+'\%' for ep in eps]
        # ax1.set_xticks(eps, tix)
        ax1.set_xticks(eps)
        
        # Plot the res data
        for i, key in enumerate(models):
            ax2.plot(eps, res[key][c].values(), ".-", label=key + " *", color=color[i])
            ax2.plot(eps, nnenum_res[key][c].values(), linestyle='--', marker='.', label=key+" ^", color=color[i])
        ax2.plot(eps, [NUM]*len(eps), "--", color="black", label="Total")
        
        # Set title and labels for the res plot
        # ax2.set_title("Res Plot", fontsize=fs)
        ax2.set_xlabel("Epsilon Perturbation (%)", fontsize=fs)
        ax2.set_ylabel("SAT", fontsize=fs)
        ax2.legend(loc='upper center', bbox_to_anchor=(0.5, 1.35), ncol=3, fontsize=fs-4)
        # ax2.legend(loc='lower left', ncols=2, fontsize=fs-4)  # show legend
        ax2.tick_params(axis='x', labelsize=fs)
        ax2.tick_params(axis='y', labelsize=fs)
        ax2.set_ylim(0, NUM+5)
        ax2.set_xticks(eps)
        ax2.set_yticks([0, 25, 50, 75, 100])
        
        # fig1.savefig(f"figures/Fig_{I+4}b_{c}.pdf", bbox_inches='tight', dpi=300)
        # fig2.savefig(f"figures/Fig_{I+4}a_{c}.pdf", bbox_inches='tight', dpi=300)
        fig1.savefig(f"figures/bodmas_time_{c}.pdf", bbox_inches='tight', dpi=300)
        fig2.savefig(f"figures/bodmas_res_{c}.pdf", bbox_inches='tight', dpi=300)
        
    return nnenum_res, nnenum_time, res, time

def make_tables(nnenum_res, nnenum_time, nnv_res, nnv_time, filename="latex_table.txt"):
    """
    Make a table of bodmas results.
    """
    # Define the header of the LaTeX table
    table_headers = "\\begin{tabularx}{\\textwidth}{YXXYYY|YYY|YYY|YYY} \n"
    header = "\\multirow{2}{*}{Metric} & \\multirow{2}{*}{Model} & \\multirow{2}{*}{Tool} &\\multicolumn{3}{c}{All} & \\multicolumn{3}{c}{Continuous \\& Discrete} & \\multicolumn{3}{c}{Discrete} & \\multicolumn{3}{c}{Continuous} \\\\\n"

    # Start creating the table
    table_content = table_headers + "\\toprule \n" + header

    categories = ['all', 'continuous_discrete', 'discrete', 'continuous']
    #
    # Add epsilon values
    #
    table_content += f" & & "
    for category in categories:
        # Add the results for nnv and nnenum for each category
        for epsilon in nnv_res["none-2"][category]:
            table_content += f"& {epsilon} \\% "
    table_content += "\\\\\n \\midrule \n"
    table_content += f"\\multirow{{6}}{{=}}{{\\rotatebox{{90}}{{Robust Accuracy}}}}"
    #
    # Add values
    #
    for model, _ in nnenum_res.items():            
        table_content += f" & \\multirow{{2}}{{*}}{{{model}}} & nnv "

        for category in categories:
            # Add the results for nnv and nnenum for each category
            for epsilon in nnv_res[model][category]:
                nnv_result = nnv_res[model][category].get(epsilon, '-')
                table_content += f"& {nnv_result} "
            
        table_content += "\\\\\n"
        table_content += f" &  & nnenum "
        for category in categories:
            for epsilon in nnenum_res[model][category]:
                nnenum_result = nnenum_res[model][category].get(epsilon, '-')
                table_content += f"& {nnenum_result} "
        table_content += "\\\\\n"
        if model == "16-2":
            table_content += "\\midrule"
        else:
            table_content += "\\cline{3-15} \n \\rule{0pt}{3ex} \n"
    #
    #
    #
    table_content += f"\\multirow{{6}}{{=}}{{\\rotatebox{{90}}{{Time (s)}}}}"
    for model, _ in nnenum_time.items():            
        table_content += f" & \\multirow{{2}}{{*}}{{{model}}} & nnv "

        for category in categories:
            # Add the results for nnv and nnenum for each category
            for epsilon in nnv_time[model][category]:
                nnv_result = nnv_time[model][category].get(epsilon, '-')
                table_content += f"& {nnv_result:.4f} "
            
        table_content += "\\\\\n"
        table_content += f" &  & nnenum "
        for catergory in categories:
            for epsilon in nnenum_time[model][category]:
                nnenum_result = nnenum_time[model][category].get(epsilon, '-')
                table_content += f"& {nnenum_result:.4f} "
        table_content += "\\\\\n"
        if model == "16-2":
            table_content += "\\bottomrule"
        else:
            table_content += "\\cline{3-15} \n \\rule{0pt}{3ex} \n"

    # Save to a text file
    with open(filename, "w") as file:
        file.write(table_content)

    print(f"Table saved to {filename}")
    
            
if __name__ == "__main__":
    nnenum_res, nnenum_time, nnv_res, nnv_time = make_plots()
    make_tables(nnenum_res, nnenum_time, nnv_res, nnv_time)
        
    
